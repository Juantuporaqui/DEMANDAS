import { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import { Maximize, Minimize, ZoomIn, ZoomOut, ChevronLeft, ChevronRight, ArrowLeft } from 'lucide-react';
import { Modal } from '../../components';
import { documentsRepo, docFilesRepo, spansRepo, linksRepo, factsRepo, partidasRepo } from '../../db/repositories';
import type { Document, DocFile, Span, Fact, Partida } from '../../types';
import * as pdfjsLib from 'pdfjs-dist';
import './PdfViewer.css';

pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('pdfjs-dist/build/pdf.worker.min.mjs', import.meta.url).toString();

export function PdfViewerPage() {
  const { id } = useParams<{ id: string }>();
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const mainRef = useRef<HTMLDivElement>(null); // Referencia para Fullscreen
  const renderTaskRef = useRef<any>(null);

  const [document, setDocument] = useState<Document | null>(null);
  const [pdfDoc, setPdfDoc] = useState<pdfjsLib.PDFDocumentProxy | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const [scale, setScale] = useState(1.0);
  const [loading, setLoading] = useState(true);
  const [rendering, setRendering] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  // Spans y otros estados (mantenidos igual)
  const [spans, setSpans] = useState<Span[]>([]);
  const [showSpanModal, setShowSpanModal] = useState(false);
  const [facts, setFacts] = useState<Fact[]>([]);
  const [partidas, setPartidas] = useState<Partida[]>([]);

  // Lógica de Zoom Táctil Mejorada
  const touchState = useRef({ startDist: 0, startScale: 1, isPinching: false });

  // Carga de datos (simplificada para brevedad, mantener lógica original de repositorios)
  useEffect(() => { if (id) loadDocument(id); }, [id]);

  async function loadDocument(docId: string) {
    try {
      setLoading(true);
      const doc = await documentsRepo.getById(docId);
      if (!doc) return navigate('/documents');
      setDocument(doc);

      // Obtener buffer del archivo (mantener tu lógica de docFilesRepo)
      const file = await docFilesRepo.getById(doc.fileId);
      if (!file) throw new Error("Archivo no encontrado");
      const arrayBuffer = await file.blob.arrayBuffer();

      const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
      const pdf = await loadingTask.promise;
      setPdfDoc(pdf);
      setTotalPages(pdf.numPages);

      const docSpans = await spansRepo.getByDocumentId(docId);
      setSpans(docSpans);
    } catch (err) {
      console.error(err);
      alert("Error al cargar");
    } finally { setLoading(false); }
  }

  // --- GESTOS TÁCTILES MEJORADOS ---
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 2) {
        touchState.current.isPinching = true;
        touchState.current.startDist = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        touchState.current.startScale = scale;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (touchState.current.isPinching && e.touches.length === 2) {
        e.preventDefault();
        const dist = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        const ratio = dist / touchState.current.startDist;
        const tempScale = Math.min(Math.max(0.5, touchState.current.startScale * ratio), 4);
        
        // Efecto visual inmediato
        if (canvasRef.current) {
          canvasRef.current.style.transform = `scale(${tempScale / scale})`;
        }
      }
    };

    const handleTouchEnd = () => {
      if (touchState.current.isPinching) {
        touchState.current.isPinching = false;
        if (canvasRef.current) {
          const transform = canvasRef.current.style.transform;
          const match = transform.match(/scale\((.+)\)/);
          if (match) {
            const finalScale = scale * parseFloat(match[1]);
            canvasRef.current.style.transform = '';
            setScale(Math.min(Math.max(0.5, finalScale), 4));
          }
        }
      }
    };

    container.addEventListener('touchstart', handleTouchStart, { passive: false });
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd);
    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
    };
  }, [scale]);

  // --- RENDERIZADO (HIDPI) ---
  const renderPage = useCallback(async (pageNum: number) => {
    if (!pdfDoc || !canvasRef.current) return;
    if (renderTaskRef.current) renderTaskRef.current.cancel();

    setRendering(true);
    try {
      const page = await pdfDoc.getPage(pageNum);
      const dpr = window.devicePixelRatio || 1;
      const viewport = page.getViewport({ scale });
      const canvas = canvasRef.current;
      const context = canvas.getContext('2d', { alpha: false });
      
      if (context) {
        canvas.width = viewport.width * dpr;
        canvas.height = viewport.height * dpr;
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        context.scale(dpr, dpr);

        renderTaskRef.current = page.render({ canvasContext: context, viewport });
        await renderTaskRef.current.promise;
      }
    } catch (err) { console.error(err); }
    finally { setRendering(false); }
  }, [pdfDoc, scale]);

  useEffect(() => { renderPage(currentPage); }, [renderPage, currentPage]);

  // --- FULLSCREEN API ---
  async function toggleFullscreen() {
    if (!mainRef.current) return;
    try {
      if (!document.fullscreenElement) {
        await mainRef.current.requestFullscreen();
        setIsFullscreen(true);
      } else {
        await document.exitFullscreen();
        setIsFullscreen(false);
      }
    } catch (err) {
      // Fallback para iOS que no soporta Fullscreen API en elementos que no sean <video>
      setIsFullscreen(!isFullscreen);
    }
  }

  // Escuchar cambios de fullscreen nativos (tecla Esc, gestos)
  useEffect(() => {
    const handler = () => setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener('fullscreenchange', handler);
    return () => document.removeEventListener('fullscreenchange', handler);
  }, []);

  if (loading) return <div className="page center-loading"><div className="spinner" /></div>;
  if (!document || !pdfDoc) return <div className="page center-error"><p>No encontrado</p></div>;

  return (
    <div ref={mainRef} className={`pdf-viewer ${isFullscreen ? 'mode-fullscreen' : ''}`}>
      <header className="pdf-header">
        <button className="btn-icon" onClick={() => navigate(-1)}><ArrowLeft size={20} /></button>
        <div className="pdf-title-container">
          <h1 className="pdf-doc-title">{document.title}</h1>
          <span className="pdf-doc-meta">Pág. {currentPage}/{totalPages}</span>
        </div>
        <button className="btn-icon" onClick={toggleFullscreen}>
          {isFullscreen ? <Minimize size={20} /> : <Maximize size={20} />}
        </button>
      </header>

      <div className="pdf-viewport" ref={containerRef}>
        <canvas ref={canvasRef} className="pdf-canvas-element" />
        {isFullscreen && (
          <button className="floating-exit-btn" onClick={toggleFullscreen}>
            <Minimize size={28} />
          </button>
        )}
      </div>

      <footer className="pdf-toolbar">
        <div className="pdf-pagination">
          <button className="btn-icon" disabled={currentPage <= 1} onClick={() => setCurrentPage(p => p - 1)}>
            <ChevronLeft size={24} />
          </button>
          <span className="page-indicator">{currentPage} / {totalPages}</span>
          <button className="btn-icon" disabled={currentPage >= totalPages} onClick={() => setCurrentPage(p => p + 1)}>
            <ChevronRight size={24} />
          </button>
        </div>
        <div className="pdf-zoom-controls">
          <button className="btn-icon" onClick={() => setScale(s => Math.max(0.5, s - 0.25))}><ZoomOut size={20} /></button>
          <span className="zoom-indicator">{Math.round(scale * 100)}%</span>
          <button className="btn-icon" onClick={() => setScale(s => Math.min(4, s + 0.25))}><ZoomIn size={20} /></button>
        </div>
      </footer>
    </div>
  );
}
